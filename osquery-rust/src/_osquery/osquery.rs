// Autogenerated by Thrift Compiler (0.15.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ExtensionCode(pub i32);

impl ExtensionCode {
  pub const EXT_SUCCESS: ExtensionCode = ExtensionCode(0);
  pub const EXT_FAILED: ExtensionCode = ExtensionCode(1);
  pub const EXT_FATAL: ExtensionCode = ExtensionCode(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::EXT_SUCCESS,
    Self::EXT_FAILED,
    Self::EXT_FATAL,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionCode> {
    let enum_value = i_prot.read_i32()?;
    Ok(ExtensionCode::from(enum_value))
  }
}

impl From<i32> for ExtensionCode {
  fn from(i: i32) -> Self {
    match i {
      0 => ExtensionCode::EXT_SUCCESS,
      1 => ExtensionCode::EXT_FAILED,
      2 => ExtensionCode::EXT_FATAL,
      _ => ExtensionCode(i)
    }
  }
}

impl From<&i32> for ExtensionCode {
  fn from(i: &i32) -> Self {
    ExtensionCode::from(*i)
  }
}

impl From<ExtensionCode> for i32 {
  fn from(e: ExtensionCode) -> i32 {
    e.0
  }
}

impl From<&ExtensionCode> for i32 {
  fn from(e: &ExtensionCode) -> i32 {
    e.0
  }
}

pub type ExtensionPluginRequest = BTreeMap<String, String>;

pub type ExtensionPluginResponse = Vec<BTreeMap<String, String>>;

pub type InternalOptionList = BTreeMap<String, InternalOptionInfo>;

pub type ExtensionRouteUUID = i64;

pub type ExtensionRouteTable = BTreeMap<String, ExtensionPluginResponse>;

pub type ExtensionRegistry = BTreeMap<String, ExtensionRouteTable>;

pub type InternalExtensionList = BTreeMap<ExtensionRouteUUID, InternalExtensionInfo>;

//
// InternalOptionInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InternalOptionInfo {
  pub value: Option<String>,
  pub default_value: Option<String>,
  pub type_: Option<String>,
}

impl InternalOptionInfo {
  #[allow(dead_code)]
  pub fn new<F1, F2, F3>(value: F1, default_value: F2, type_: F3) -> InternalOptionInfo where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>> {
    InternalOptionInfo {
      value: value.into(),
      default_value: default_value.into(),
      type_: type_.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<InternalOptionInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = InternalOptionInfo {
      value: f_1,
      default_value: f_2,
      type_: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("InternalOptionInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.default_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("default_value", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for InternalOptionInfo {
  fn default() -> Self {
    InternalOptionInfo{
      value: Some("".to_owned()),
      default_value: Some("".to_owned()),
      type_: Some("".to_owned()),
    }
  }
}

//
// InternalExtensionInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InternalExtensionInfo {
  pub name: Option<String>,
  pub version: Option<String>,
  pub sdk_version: Option<String>,
  pub min_sdk_version: Option<String>,
}

impl InternalExtensionInfo {
  #[allow(dead_code)]
  pub fn new<F1, F2, F3, F4>(name: F1, version: F2, sdk_version: F3, min_sdk_version: F4) -> InternalExtensionInfo where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>> {
    InternalExtensionInfo {
      name: name.into(),
      version: version.into(),
      sdk_version: sdk_version.into(),
      min_sdk_version: min_sdk_version.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<InternalExtensionInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = InternalExtensionInfo {
      name: f_1,
      version: f_2,
      sdk_version: f_3,
      min_sdk_version: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("InternalExtensionInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.version {
      o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sdk_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("sdk_version", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.min_sdk_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("min_sdk_version", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for InternalExtensionInfo {
  fn default() -> Self {
    InternalExtensionInfo{
      name: Some("".to_owned()),
      version: Some("".to_owned()),
      sdk_version: Some("".to_owned()),
      min_sdk_version: Some("".to_owned()),
    }
  }
}

//
// ExtensionStatus
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ExtensionStatus {
  pub code: Option<i32>,
  pub message: Option<String>,
  pub uuid: Option<ExtensionRouteUUID>,
}

impl ExtensionStatus {
  pub fn new<F1, F2, F3>(code: F1, message: F2, uuid: F3) -> ExtensionStatus where F1: Into<Option<i32>>, F2: Into<Option<String>>, F3: Into<Option<ExtensionRouteUUID>> {
    ExtensionStatus {
      code: code.into(),
      message: message.into(),
      uuid: uuid.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionStatus> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<ExtensionRouteUUID> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExtensionStatus {
      code: f_1,
      message: f_2,
      uuid: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ExtensionStatus");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.code {
      o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.uuid {
      o_prot.write_field_begin(&TFieldIdentifier::new("uuid", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ExtensionStatus {
  fn default() -> Self {
    ExtensionStatus{
      code: Some(0),
      message: Some("".to_owned()),
      uuid: Some(0),
    }
  }
}

//
// ExtensionResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ExtensionResponse {
  pub status: Option<ExtensionStatus>,
  pub response: Option<ExtensionPluginResponse>,
}

impl ExtensionResponse {
  pub fn new<F1, F2>(status: F1, response: F2) -> ExtensionResponse where F1: Into<Option<ExtensionStatus>>, F2: Into<Option<ExtensionPluginResponse>> {
    ExtensionResponse {
      status: status.into(),
      response: response.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ExtensionStatus> = None;
    let mut f_2: Option<ExtensionPluginResponse> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ExtensionStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<BTreeMap<String, String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let map_ident = i_prot.read_map_begin()?;
            let mut list_elem_0: BTreeMap<String, String> = BTreeMap::new();
            for _ in 0..map_ident.size {
              let map_key_1 = i_prot.read_string()?;
              let map_val_2 = i_prot.read_string()?;
              list_elem_0.insert(map_key_1, map_val_2);
            }
            i_prot.read_map_end()?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExtensionResponse {
      status: f_1,
      response: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ExtensionResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.status {
      o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.response {
      o_prot.write_field_begin(&TFieldIdentifier::new("response", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Map, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, e.len() as i32))?;
        for (k, v) in e {
          o_prot.write_string(k)?;
          o_prot.write_string(v)?;
        }
        o_prot.write_map_end()?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ExtensionResponse {
  fn default() -> Self {
    ExtensionResponse{
      status: None,
      response: Some(Vec::new()),
    }
  }
}

//
// ExtensionException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ExtensionException {
  pub code: Option<i32>,
  pub message: Option<String>,
  pub uuid: Option<ExtensionRouteUUID>,
}

impl ExtensionException {
  pub fn new<F1, F2, F3>(code: F1, message: F2, uuid: F3) -> ExtensionException where F1: Into<Option<i32>>, F2: Into<Option<String>>, F3: Into<Option<ExtensionRouteUUID>> {
    ExtensionException {
      code: code.into(),
      message: message.into(),
      uuid: uuid.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<ExtensionRouteUUID> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExtensionException {
      code: f_1,
      message: f_2,
      uuid: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ExtensionException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.code {
      o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.uuid {
      o_prot.write_field_begin(&TFieldIdentifier::new("uuid", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ExtensionException {
  fn default() -> Self {
    ExtensionException{
      code: Some(0),
      message: Some("".to_owned()),
      uuid: Some(0),
    }
  }
}

impl Error for ExtensionException {}

impl From<ExtensionException> for thrift::Error {
  fn from(e: ExtensionException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for ExtensionException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw ExtensionException")
  }
}

//
// Extension service client
//

pub trait TExtensionSyncClient {
  fn ping(&mut self) -> thrift::Result<ExtensionStatus>;
  fn call(&mut self, registry: String, item: String, request: ExtensionPluginRequest) -> thrift::Result<ExtensionResponse>;
  fn shutdown(&mut self) -> thrift::Result<()>;
}

pub trait TExtensionSyncClientMarker {}

pub struct ExtensionSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> ExtensionSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  #[allow(dead_code)]
  pub fn new(input_protocol: IP, output_protocol: OP) -> ExtensionSyncClient<IP, OP> {
    ExtensionSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for ExtensionSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TExtensionSyncClientMarker for ExtensionSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TExtensionSyncClientMarker> TExtensionSyncClient for C {
  fn ping(&mut self) -> thrift::Result<ExtensionStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("ping", TMessageType::Call, self.sequence_number());
        let call_args = ExtensionPingArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("ping", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ExtensionPingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn call(&mut self, registry: String, item: String, request: ExtensionPluginRequest) -> thrift::Result<ExtensionResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("call", TMessageType::Call, self.sequence_number());
        let call_args = ExtensionCallArgs { registry, item, request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("call", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ExtensionCallResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shutdown(&mut self) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("shutdown", TMessageType::Call, self.sequence_number());
        let call_args = ExtensionShutdownArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("shutdown", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ExtensionShutdownResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// Extension service processor
//

pub trait ExtensionSyncHandler {
  fn handle_ping(&self) -> thrift::Result<ExtensionStatus>;
  fn handle_call(&self, registry: String, item: String, request: ExtensionPluginRequest) -> thrift::Result<ExtensionResponse>;
  fn handle_shutdown(&self) -> thrift::Result<()>;
}

pub struct ExtensionSyncProcessor<H: ExtensionSyncHandler> {
  handler: H,
}

impl <H: ExtensionSyncHandler> ExtensionSyncProcessor<H> {
  #[allow(dead_code)]
  pub fn new(handler: H) -> ExtensionSyncProcessor<H> {
    ExtensionSyncProcessor {
      handler,
    }
  }
  fn process_ping(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TExtensionProcessFunctions::process_ping(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_call(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TExtensionProcessFunctions::process_call(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shutdown(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TExtensionProcessFunctions::process_shutdown(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TExtensionProcessFunctions;

impl TExtensionProcessFunctions {
  pub fn process_ping<H: ExtensionSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ExtensionPingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_ping() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("ping", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ExtensionPingResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("ping", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("ping", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_call<H: ExtensionSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ExtensionCallArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_call(args.registry, args.item, args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("call", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ExtensionCallResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("call", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("call", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shutdown<H: ExtensionSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ExtensionShutdownArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shutdown() {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("shutdown", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ExtensionShutdownResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("shutdown", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("shutdown", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: ExtensionSyncHandler> TProcessor for ExtensionSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "ping" => {
        self.process_ping(message_ident.sequence_number, i_prot, o_prot)
      },
      "call" => {
        self.process_call(message_ident.sequence_number, i_prot, o_prot)
      },
      "shutdown" => {
        self.process_shutdown(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// ExtensionPingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ExtensionPingArgs {
}

impl ExtensionPingArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionPingArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExtensionPingArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ping_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ExtensionPingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ExtensionPingResult {
  result_value: Option<ExtensionStatus>,
}

impl ExtensionPingResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionPingResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ExtensionStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ExtensionStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExtensionPingResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ExtensionPingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ExtensionStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ExtensionPing"
          )
        )
      )
    }
  }
}

//
// ExtensionCallArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ExtensionCallArgs {
  registry: String,
  item: String,
  request: ExtensionPluginRequest,
}

impl ExtensionCallArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionCallArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<ExtensionPluginRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_3 = i_prot.read_string()?;
            let map_val_4 = i_prot.read_string()?;
            val.insert(map_key_3, map_val_4);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ExtensionCallArgs.registry", &f_1)?;
    verify_required_field_exists("ExtensionCallArgs.item", &f_2)?;
    verify_required_field_exists("ExtensionCallArgs.request", &f_3)?;
    let ret = ExtensionCallArgs {
      registry: f_1.expect("auto-generated code should have checked for presence of required fields"),
      item: f_2.expect("auto-generated code should have checked for presence of required fields"),
      request: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("call_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("registry", TType::String, 1))?;
    o_prot.write_string(&self.registry)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("item", TType::String, 2))?;
    o_prot.write_string(&self.item)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Map, 3))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.request.len() as i32))?;
    for (k, v) in &self.request {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ExtensionCallResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ExtensionCallResult {
  result_value: Option<ExtensionResponse>,
}

impl ExtensionCallResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionCallResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ExtensionResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ExtensionResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExtensionCallResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ExtensionCallResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ExtensionResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ExtensionCall"
          )
        )
      )
    }
  }
}

//
// ExtensionShutdownArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ExtensionShutdownArgs {
}

impl ExtensionShutdownArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionShutdownArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExtensionShutdownArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("shutdown_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ExtensionShutdownResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ExtensionShutdownResult {
}

impl ExtensionShutdownResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionShutdownResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExtensionShutdownResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ExtensionShutdownResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ExtensionManager service client
//

pub trait TExtensionManagerSyncClient : TExtensionSyncClient {
  fn extensions(&mut self) -> thrift::Result<InternalExtensionList>;
  fn options(&mut self) -> thrift::Result<InternalOptionList>;
  fn register_extension(&mut self, info: InternalExtensionInfo, registry: ExtensionRegistry) -> thrift::Result<ExtensionStatus>;
  fn deregister_extension(&mut self, uuid: ExtensionRouteUUID) -> thrift::Result<ExtensionStatus>;
  fn query(&mut self, sql: String) -> thrift::Result<ExtensionResponse>;
  fn get_query_columns(&mut self, sql: String) -> thrift::Result<ExtensionResponse>;
}

pub trait TExtensionManagerSyncClientMarker {}

pub struct ExtensionManagerSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> ExtensionManagerSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> ExtensionManagerSyncClient<IP, OP> {
    ExtensionManagerSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for ExtensionManagerSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TExtensionManagerSyncClientMarker for ExtensionManagerSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}
impl <IP, OP> TExtensionSyncClientMarker for ExtensionManagerSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TExtensionManagerSyncClientMarker + TExtensionSyncClientMarker> TExtensionManagerSyncClient for C {
  fn extensions(&mut self) -> thrift::Result<InternalExtensionList> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("extensions", TMessageType::Call, self.sequence_number());
        let call_args = ExtensionManagerExtensionsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("extensions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ExtensionManagerExtensionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn options(&mut self) -> thrift::Result<InternalOptionList> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("options", TMessageType::Call, self.sequence_number());
        let call_args = ExtensionManagerOptionsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("options", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ExtensionManagerOptionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_extension(&mut self, info: InternalExtensionInfo, registry: ExtensionRegistry) -> thrift::Result<ExtensionStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("registerExtension", TMessageType::Call, self.sequence_number());
        let call_args = ExtensionManagerRegisterExtensionArgs { info, registry };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("registerExtension", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ExtensionManagerRegisterExtensionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn deregister_extension(&mut self, uuid: ExtensionRouteUUID) -> thrift::Result<ExtensionStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("deregisterExtension", TMessageType::Call, self.sequence_number());
        let call_args = ExtensionManagerDeregisterExtensionArgs { uuid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("deregisterExtension", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ExtensionManagerDeregisterExtensionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn query(&mut self, sql: String) -> thrift::Result<ExtensionResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("query", TMessageType::Call, self.sequence_number());
        let call_args = ExtensionManagerQueryArgs { sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("query", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ExtensionManagerQueryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_query_columns(&mut self, sql: String) -> thrift::Result<ExtensionResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getQueryColumns", TMessageType::Call, self.sequence_number());
        let call_args = ExtensionManagerGetQueryColumnsArgs { sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getQueryColumns", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ExtensionManagerGetQueryColumnsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// ExtensionManager service processor
//

pub trait ExtensionManagerSyncHandler : ExtensionSyncHandler {
  fn handle_extensions(&self) -> thrift::Result<InternalExtensionList>;
  fn handle_options(&self) -> thrift::Result<InternalOptionList>;
  fn handle_register_extension(&self, info: InternalExtensionInfo, registry: ExtensionRegistry) -> thrift::Result<ExtensionStatus>;
  fn handle_deregister_extension(&self, uuid: ExtensionRouteUUID) -> thrift::Result<ExtensionStatus>;
  fn handle_query(&self, sql: String) -> thrift::Result<ExtensionResponse>;
  fn handle_get_query_columns(&self, sql: String) -> thrift::Result<ExtensionResponse>;
}

pub struct ExtensionManagerSyncProcessor<H: ExtensionManagerSyncHandler> {
  handler: H,
}

impl <H: ExtensionManagerSyncHandler> ExtensionManagerSyncProcessor<H> {
  pub fn new(handler: H) -> ExtensionManagerSyncProcessor<H> {
    ExtensionManagerSyncProcessor {
      handler,
    }
  }
  fn process_extensions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TExtensionManagerProcessFunctions::process_extensions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_options(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TExtensionManagerProcessFunctions::process_options(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_extension(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TExtensionManagerProcessFunctions::process_register_extension(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_deregister_extension(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TExtensionManagerProcessFunctions::process_deregister_extension(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_query(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TExtensionManagerProcessFunctions::process_query(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_query_columns(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TExtensionManagerProcessFunctions::process_get_query_columns(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_ping(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TExtensionProcessFunctions::process_ping(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_call(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TExtensionProcessFunctions::process_call(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shutdown(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TExtensionProcessFunctions::process_shutdown(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TExtensionManagerProcessFunctions;

impl TExtensionManagerProcessFunctions {
  pub fn process_extensions<H: ExtensionManagerSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ExtensionManagerExtensionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_extensions() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("extensions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ExtensionManagerExtensionsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("extensions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("extensions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_options<H: ExtensionManagerSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ExtensionManagerOptionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_options() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("options", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ExtensionManagerOptionsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("options", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("options", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_extension<H: ExtensionManagerSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ExtensionManagerRegisterExtensionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_extension(args.info, args.registry) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("registerExtension", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ExtensionManagerRegisterExtensionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("registerExtension", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("registerExtension", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_deregister_extension<H: ExtensionManagerSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ExtensionManagerDeregisterExtensionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_deregister_extension(args.uuid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("deregisterExtension", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ExtensionManagerDeregisterExtensionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("deregisterExtension", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("deregisterExtension", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_query<H: ExtensionManagerSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ExtensionManagerQueryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_query(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("query", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ExtensionManagerQueryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("query", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("query", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_query_columns<H: ExtensionManagerSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ExtensionManagerGetQueryColumnsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_query_columns(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getQueryColumns", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ExtensionManagerGetQueryColumnsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getQueryColumns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getQueryColumns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: ExtensionManagerSyncHandler> TProcessor for ExtensionManagerSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "extensions" => {
        self.process_extensions(message_ident.sequence_number, i_prot, o_prot)
      },
      "options" => {
        self.process_options(message_ident.sequence_number, i_prot, o_prot)
      },
      "registerExtension" => {
        self.process_register_extension(message_ident.sequence_number, i_prot, o_prot)
      },
      "deregisterExtension" => {
        self.process_deregister_extension(message_ident.sequence_number, i_prot, o_prot)
      },
      "query" => {
        self.process_query(message_ident.sequence_number, i_prot, o_prot)
      },
      "getQueryColumns" => {
        self.process_get_query_columns(message_ident.sequence_number, i_prot, o_prot)
      },
      "ping" => {
        self.process_ping(message_ident.sequence_number, i_prot, o_prot)
      },
      "call" => {
        self.process_call(message_ident.sequence_number, i_prot, o_prot)
      },
      "shutdown" => {
        self.process_shutdown(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// ExtensionManagerExtensionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ExtensionManagerExtensionsArgs {
}

impl ExtensionManagerExtensionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionManagerExtensionsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExtensionManagerExtensionsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("extensions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ExtensionManagerExtensionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ExtensionManagerExtensionsResult {
  result_value: Option<InternalExtensionList>,
}

impl ExtensionManagerExtensionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionManagerExtensionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<InternalExtensionList> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<ExtensionRouteUUID, InternalExtensionInfo> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_5 = i_prot.read_i64()?;
            let map_val_6 = InternalExtensionInfo::read_from_in_protocol(i_prot)?;
            val.insert(map_key_5, map_val_6);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExtensionManagerExtensionsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ExtensionManagerExtensionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I64, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i64(*k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<InternalExtensionList> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ExtensionManagerExtensions"
          )
        )
      )
    }
  }
}

//
// ExtensionManagerOptionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ExtensionManagerOptionsArgs {
}

impl ExtensionManagerOptionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionManagerOptionsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExtensionManagerOptionsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("options_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ExtensionManagerOptionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ExtensionManagerOptionsResult {
  result_value: Option<InternalOptionList>,
}

impl ExtensionManagerOptionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionManagerOptionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<InternalOptionList> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, InternalOptionInfo> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_7 = i_prot.read_string()?;
            let map_val_8 = InternalOptionInfo::read_from_in_protocol(i_prot)?;
            val.insert(map_key_7, map_val_8);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExtensionManagerOptionsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ExtensionManagerOptionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<InternalOptionList> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ExtensionManagerOptions"
          )
        )
      )
    }
  }
}

//
// ExtensionManagerRegisterExtensionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ExtensionManagerRegisterExtensionArgs {
  info: InternalExtensionInfo,
  registry: ExtensionRegistry,
}

impl ExtensionManagerRegisterExtensionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionManagerRegisterExtensionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<InternalExtensionInfo> = None;
    let mut f_2: Option<ExtensionRegistry> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = InternalExtensionInfo::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, ExtensionRouteTable> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_9 = i_prot.read_string()?;
            let map_ident = i_prot.read_map_begin()?;
            let mut map_val_10: BTreeMap<String, ExtensionPluginResponse> = BTreeMap::new();
            for _ in 0..map_ident.size {
              let map_key_11 = i_prot.read_string()?;
              let list_ident = i_prot.read_list_begin()?;
              let mut map_val_12: Vec<BTreeMap<String, String>> = Vec::with_capacity(list_ident.size as usize);
              for _ in 0..list_ident.size {
                let map_ident = i_prot.read_map_begin()?;
                let mut list_elem_13: BTreeMap<String, String> = BTreeMap::new();
                for _ in 0..map_ident.size {
                  let map_key_14 = i_prot.read_string()?;
                  let map_val_15 = i_prot.read_string()?;
                  list_elem_13.insert(map_key_14, map_val_15);
                }
                i_prot.read_map_end()?;
                map_val_12.push(list_elem_13);
              }
              i_prot.read_list_end()?;
              map_val_10.insert(map_key_11, map_val_12);
            }
            i_prot.read_map_end()?;
            val.insert(map_key_9, map_val_10);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ExtensionManagerRegisterExtensionArgs.info", &f_1)?;
    verify_required_field_exists("ExtensionManagerRegisterExtensionArgs.registry", &f_2)?;
    let ret = ExtensionManagerRegisterExtensionArgs {
      info: f_1.expect("auto-generated code should have checked for presence of required fields"),
      registry: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("registerExtension_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("info", TType::Struct, 1))?;
    self.info.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("registry", TType::Map, 2))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, self.registry.len() as i32))?;
    for (k, v) in &self.registry {
      o_prot.write_string(k)?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::List, v.len() as i32))?;
      for (k, v) in v {
        o_prot.write_string(k)?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Map, v.len() as i32))?;
        for e in v {
          o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, e.len() as i32))?;
          for (k, v) in e {
            o_prot.write_string(k)?;
            o_prot.write_string(v)?;
          }
          o_prot.write_map_end()?;
        }
        o_prot.write_list_end()?;
      }
      o_prot.write_map_end()?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ExtensionManagerRegisterExtensionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ExtensionManagerRegisterExtensionResult {
  result_value: Option<ExtensionStatus>,
}

impl ExtensionManagerRegisterExtensionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionManagerRegisterExtensionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ExtensionStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ExtensionStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExtensionManagerRegisterExtensionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ExtensionManagerRegisterExtensionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ExtensionStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ExtensionManagerRegisterExtension"
          )
        )
      )
    }
  }
}

//
// ExtensionManagerDeregisterExtensionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ExtensionManagerDeregisterExtensionArgs {
  uuid: ExtensionRouteUUID,
}

impl ExtensionManagerDeregisterExtensionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionManagerDeregisterExtensionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ExtensionRouteUUID> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ExtensionManagerDeregisterExtensionArgs.uuid", &f_1)?;
    let ret = ExtensionManagerDeregisterExtensionArgs {
      uuid: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("deregisterExtension_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("uuid", TType::I64, 1))?;
    o_prot.write_i64(self.uuid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ExtensionManagerDeregisterExtensionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ExtensionManagerDeregisterExtensionResult {
  result_value: Option<ExtensionStatus>,
}

impl ExtensionManagerDeregisterExtensionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionManagerDeregisterExtensionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ExtensionStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ExtensionStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExtensionManagerDeregisterExtensionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ExtensionManagerDeregisterExtensionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ExtensionStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ExtensionManagerDeregisterExtension"
          )
        )
      )
    }
  }
}

//
// ExtensionManagerQueryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ExtensionManagerQueryArgs {
  sql: String,
}

impl ExtensionManagerQueryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionManagerQueryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ExtensionManagerQueryArgs.sql", &f_1)?;
    let ret = ExtensionManagerQueryArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("query_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ExtensionManagerQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ExtensionManagerQueryResult {
  result_value: Option<ExtensionResponse>,
}

impl ExtensionManagerQueryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionManagerQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ExtensionResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ExtensionResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExtensionManagerQueryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ExtensionManagerQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ExtensionResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ExtensionManagerQuery"
          )
        )
      )
    }
  }
}

//
// ExtensionManagerGetQueryColumnsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ExtensionManagerGetQueryColumnsArgs {
  sql: String,
}

impl ExtensionManagerGetQueryColumnsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionManagerGetQueryColumnsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ExtensionManagerGetQueryColumnsArgs.sql", &f_1)?;
    let ret = ExtensionManagerGetQueryColumnsArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getQueryColumns_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ExtensionManagerGetQueryColumnsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ExtensionManagerGetQueryColumnsResult {
  result_value: Option<ExtensionResponse>,
}

impl ExtensionManagerGetQueryColumnsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExtensionManagerGetQueryColumnsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ExtensionResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ExtensionResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExtensionManagerGetQueryColumnsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ExtensionManagerGetQueryColumnsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ExtensionResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ExtensionManagerGetQueryColumns"
          )
        )
      )
    }
  }
}

